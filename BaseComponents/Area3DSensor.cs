using Godot;
using Jmo.Core;
using Jmo.AI.Perception.Strategies;
using System;

namespace Jmo.AI.Perception.Sensors
{
    /// <summary>
    /// A general-purpose sensor that uses a Godot Area3D to detect identifiable objects within its volume.
    /// This component is highly performant and ideal for creating simple, radius-based detection zones for
    /// any purpose, such as proximity, touch, magical auras, or hearing range. It treats any object
    /// entering its volume as having a maximum confidence level of 1.0.
    /// </summary>
    [GlobalClass]
    public partial class Area3DSensor : Area3D, IAISensor
    {
        /// <summary>
        /// The default decay strategy for memories generated by this sensor. A LinearMemoryDecay resource
        /// is a good default. This can be overridden by an IdentifiableComponent's specific settings.
        /// </summary>
        [Export] private Resource _defaultDecayStrategy;

        private MemoryDecayStrategy _decayStrategy;

        /// <inheritdoc/>
        public event EventHandler<PerceptEventArgs> PerceptUpdated;

        public override void _Ready()
        {
            if (_defaultDecayStrategy is MemoryDecayStrategy strategy)
            {
                _decayStrategy = strategy;
            }
            else
            {
                // Warn the user but do not fail, as a decay strategy might be provided by the detectable object.
                GD.PrintWarning($"Area3DSensor on '{Name}' is missing a valid DefaultDecayStrategy resource. Percepts may not decay unless overridden by an IdentifiableComponent.");
            }

            // Connect to the Area3D's built-in signals for efficient, event-driven detection.
            BodyEntered += OnBodyEntered;
            BodyExited += OnBodyExited;
        }

        private void OnBodyEntered(Node3D body)
        {
            ProcessDetection(body, 1.0f); // Entering the area means maximum confidence.
        }

        private void OnBodyExited(Node3D body)
        {
            ProcessDetection(body, 0.0f); // Exiting the area means zero confidence (object is lost).
        }

        private void ProcessDetection(Node3D body, float confidence)
        {
            // The object that entered must have an IdentifiableComponent for our system to understand it.
            if (body is not CollisionObject3D coll ||
                !coll.TryGetFirstChildOfType(out IdentifiableComponent? identifiable))
            {
                return;
            }

            MemoryDecayStrategy finalStrategy = (identifiable.OverrideDecayStrategy as MemoryDecayStrategy) ?? _decayStrategy;
            if (finalStrategy == null)
            {
                // This is a critical fallback case. A percept without a decay strategy is problematic.
                // It will either never decay or cause null reference exceptions.
                return;
            }

            // Attempt to get velocity information from common physics bodies.
            Vector3 velocity = (body is RigidBody3D rb) ? rb.LinearVelocity : Vector3.Zero;
            if (body is CharacterBody3D cb) { velocity = cb.Velocity; }

            // Create the stateless percept and fire the event for the manager to process.
            var percept = new Percept(body, body.GlobalPosition, velocity, identifiable.Identity, confidence, finalStrategy);
            PerceptUpdated?.Invoke(this, new PerceptEventArgs(percept, this));
        }

        /// <inheritdoc/>
        public Godot.Node GetInterfaceNode() => this;
    }
}