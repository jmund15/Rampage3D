using Godot;
using Jmo.Core;
using Jmo.AI.Perception.Strategies;
using System.Collections.Generic;
using System;

// TODO ALL: reevaluate nullable best practices in godot and .net 8.0 (<Nullable>enable</Nullable> in csproj)

namespace Jmo.AI.Perception.Sensors
{
    /// <summary>
    /// A general-purpose sensor that uses a collection of child RayCast3D nodes to detect objects.
    /// This component is ideal for creating directional scanning, such as forward-facing "feelers",
    /// sonar pings, or basic, non-line-of-sight vision cones. Confidence is calculated based on
    /// the distance of the detected object relative to the ray's length.
    /// </summary>
    [GlobalClass]
    public partial class Raycast3DArraySensor : Node3D, IAISensor
    {
        /// <summary>The default decay strategy for memories generated by this sensor.</summary>
        [Export] private MemoryDecayStrategy _defaultDecayStrategy;
        private MemoryDecayStrategy? _decayStrategy;

        /// <summary>
        /// How frequently, in seconds, the sensor will check its raycasts. Polling on a timer
        /// is more performant than checking every physics frame.
        /// </summary>
        [Export(PropertyHint.Range, "0.05,1.0,0.01")]
        private float _pollingInterval = 0.1f;

        // Caches what each ray is currently "seeing" to detect state changes (new vs. lost targets).
        private readonly Dictionary<RayCast3D, Node3D?> _currentlySensedByRay = new();
        private Timer _pollingTimer;

        /// <inheritdoc/>
        public event EventHandler<PerceptEventArgs> PerceptUpdated;

        public override void _Ready()
        {
            if (_defaultDecayStrategy is MemoryDecayStrategy strategy)
            {
                _decayStrategy = strategy;
            }

            foreach (var node in GetChildren())
            {
                if (node is RayCast3D ray)
                {
                    _currentlySensedByRay.Add(ray, null); // Initialize all rays as seeing nothing.
                }
            }

            _pollingTimer = new Timer { WaitTime = _pollingInterval, Autostart = true };
            _pollingTimer.Timeout += PollRaycasts;
            AddChild(_pollingTimer);
        }

        private void PollRaycasts()
        {
            // Using a copy of the keys allows for safe modification of the dictionary if ever needed.
            var rays = new List<RayCast3D>(_currentlySensedByRay.Keys);

            foreach (var ray in rays)
            {
                var previousCollider = _currentlySensedByRay[ray];
                var currentCollider = ray.IsColliding() ? ray.GetCollider() as Node3D : null;

                if (currentCollider != previousCollider)
                {
                    // If the ray was previously seeing an object, signal that it is now lost.
                    if (previousCollider != null)
                    {
                        ProcessDetection(previousCollider, 0.0f, 0.0f); // Confidence 0.0 means "lost".
                    }

                    // If the ray is now seeing a new object, process the new detection.
                    if (currentCollider != null)
                    {
                        float distance = GlobalPosition.DistanceTo(ray.GetCollisionPoint());
                        ProcessDetection(currentCollider, distance, ray.TargetPosition.Length());
                    }

                    _currentlySensedByRay[ray] = currentCollider;
                }
            }
        }

        private void ProcessDetection(Node3D body, float distance, float maxDistance)
        {
            if (body is not CollisionObject3D coll || !coll.TryGetFirstChildOfType(out IdentifiableComponent? identifiable) || identifiable == null)
            {
                return;
            }

            // Confidence is calculated as an inverse of distance. Closer is more confident.
            float confidence = (maxDistance > 0.0f) ? Mathf.Max(0.0f, 1.0f - (distance / maxDistance)) : 0.0f;

            MemoryDecayStrategy finalStrategy = (identifiable.OverrideDecayStrategy as MemoryDecayStrategy) ?? _decayStrategy;
            if (finalStrategy == null) return;

            Vector3 velocity = (body is RigidBody3D rb) ? rb.LinearVelocity : Vector3.Zero;
            if (body is CharacterBody3D cb) { velocity = cb.Velocity; }

            var percept = new Percept(body, body.GlobalPosition, velocity, identifiable.Identity, confidence, finalStrategy);
            PerceptUpdated?.Invoke(this, new PerceptEventArgs(percept, this));
        }

        /// <inheritdoc/>
        public Node GetInterfaceNode() => this;
    }
}